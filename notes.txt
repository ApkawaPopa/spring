lesson4

Через сеттеры внедряется зависимость с помощью тега property с указанием name=имя поля и value=значение поля
values будем брать из файла *.properties, предварительно импортировав его в applicationContext с помощью тега <context:property-placeholder location="classpath:...">

При создании бина спринг сам ищет нужный конструктор в зависимости от внутренних <constructor-arg>

В property name=.. поиск ведется по сеттеру set..., где ... в camelCase'е

Надо создать в плеере две зависимости name и volume, внедрить все три зависимости с помощью property

Создать musicPlayer.properties и указать там name=...
volume=...

Нужно изменить плеер так, чтобы он мог проигрывать сразу много музыкальных жанров, то есть список
Потом внедрить все музыкальные жанры в плеер с помощью внедрения списка бинов

Можно передать лист бинов сразу через
<property/constructor-arg>
    <list>
        <ref="bean1">
        <ref="bean2">
        ...
    </list>
</...>

А можно как я сделал, тогда создается отдельный бин под лист

Выключил Inline completion


lesson5

Ставим scope=singleton для musicPlayer и убеждаемся, что они равны в TestSpring
То есть сравним ссылки и посмотрим, что будет при изменении громкости в одном из объектов
Затем ставим scope=prototype и смотрим, что ссылки теперь разные и что громкость меняется не в обеих переменных


lesson6

Добавим init-method и destroy-method в каком-то жанре музыки
В контексте с бинами для этого бина пропишем названия этих методов в init-method и destroy-method
Проверим, что init вызывается при создании бина, а точнее при создании контекста
Проверим, что дестрой вызывается при закрытии контекста, то есть при уничтожении бина

Модификатор доступа у этих методов может быть любой
Возвращаться может что угодно, но спринг все равно не будет это использовать
Входных аргументов у них быть не должно

У scope=prototype бинов не вызывается destroy-method
Спринг отдает бины клиенту и больше о них не заботится

Задание: посмотреть, вызывается ли дестрой метод у прототип бинов и посмотреть, сколько раз вызовется инит метод при создании нескольких прототип бинов

Первый инит вызывается при создании контекста у прототайпа, а дальше по мере вызова getBean()

factory-method:
    есть абстрактный класс Creator, который содержит всю бизнес логику обработки объекта, кроме реализации метода для создания экземпляра объекта
    при этом метод создания объекта абстрактный и возвращает интерфейс объектов, которые будут в итоге обработаны
    для каждого конкретного типа объекта мы создаем отдельные фабрики, в которых переопределяем метод создания объекта со всеми особенностями этого типа

Задание: создать фабричный метод в каком-то жанре и указать соответствующему бину называние этого метода через factory-method

Несмотря на то, что у нас будет фабричный метод, он все еще вызовется единственный раз при вызове getBean, если у нас scope=Singleton


lesson7

Теперь будем создавать бины через аннотации, а конкретнее пока что через @Component
Туда можно передать id=..., а иначе будет создан бин с названием класса с маленькой буквы

Сначала уберем создание всех бинов из xml конфигурации, а затем через тэг context:component-scan
Включим сканирование классов на бины передав base-package=путь до пути со всеми java-классами

Затем создадим бины для всех жанров музыки через Component и проверим в тест спринге


lesson8

Внедрять зависимости можно через @Autowired, который среди всех бинов ищет те, которые подходят по указанному для поля интерфейсу/классу

Ошибка будет, если таких бинов не нашлось или если их больше одного

При использовании внедрения зависимости через сеттер для Autowired неважно, какое будет название метода-сеттера

Для внедрения всех зависимостей в конструкторе можно поставить над ним Autowired

Прак
Создадим класс компьютер с id и musicPlayer'ом
В конструкторе установим id = 1, а musicPlayer внедрим через Autowired над конструктором
Переопределим ему toString(), чтобы возвращался id и какая музыка в плеере
В плеере сохраним все жанры музыки и внедрим их через конструктор

В итоге Autowired можно использовать с сеттером, конструктором или самим полем
В проекте лучше везде использовать одинаковый метод внедрения для лучшей читаемости кода


lesson9

Для решения проблемы с неоднозначностью подбора бинов, то есть когда их больше 1 на поле, можно использовать аннотацию @Qualifier
В ней указывается строчное имя бина, который нужно внедрить

Для внедрения зависимостей в конструкторе нужно для каждого аргумента в конструкторе указать Qualifier перед объявлением аргумента

Прак
Пусть внутри плеера будет две музыки, каждая с интерфейсом Music
Внедрим зависимости через конструктор, указав для каждой Qualifier, тк иначе будет неоднозначность и вылезет ошибка

Самозад:
1 Создать массив или список из 3 песен для каждого жанра
2 В плеере должны внедряться бины обоих жанров
3 Создать enum с жанрами музыки
4 Принимать в play() созданный enum
5 В зависимости от переданного жанра производить рандомную песню из списка песен этого жанра


lesson10

@Value("$название_ключа") - так можно внедрять константные зависимости из файла .properties с помощью аннотаций
При этом все так же надо будет создать этот файл и указать в нем пары ключ=значение и импортировать его в конфигурации
с помощью context:property-placeholder location="classpath:путь_до_файла"

Для создания бина с определенной областью видимости можно использовать после аннотации Component аннотацию
Scope("название_области")

@PostConstruct пишется над init-method'ом, а @PreDestroy - над destroy-method'ом
Для использования PreDestroy и PostContract

Эти аннотации являются аналогами уже изученного и ограничения на них такие же

Для работы этих аннотаций на Spring 5.3.* нужно подключить зависимость javax annotation-api
Для работы этих аннотаций 6.* нужно подключить зависимость jakarta annotation-api, которая с jdk 9 поглотила javax annotations-api

Задание
1 Подключаем файл .properties для плеера и внедряем значения имени и громкости с помощью них
Затем проверяем, внедрились ли они
2 Укажем scope singleton для классической музыки и проверим, равны ли два полученных из контекста бина этой музыки
Затем поменяем на prototype и увидим, что бины ссылаются на разные объекты
3 Проверим инит метод и дестрой метод для классической музыки, создав их


lesson11

@Configuration
Над классом, который будет использоваться в качестве конфигурации контекста спринг-приложения

@PropertySource("путь до .properties файла")
Тоже над классом-конфигурацией

@ComponentScan("путь до каталога со всеми java-классами")
Тоже над классом-конфигурацией

@Bean - для создания бина, над методом создания
Там можно прописать, как будет создаваться бин: с помощью фабрики или конструктора

Задание
Перенести всю конфигурацию в конфигурационный класс

Самозад
Сделать чтобы в плеере принимался лист из жанров музыки и еще один жанр
Внедрить с помощью бина-листа все три жанра в бин плеера и сделать в методе
play рандомный выбор жанра для воспроизведения


lesson12

Создаем собственное spring-mvc приложение, которое будет исполняться в tomcat
Для контроллера используется аннотация Controller, которая является надмножеством Component

web.xml считывается apache tomcat для конфигурации, а applicationContextMVC - конфигурация спринга

lesson13

Создать пакет config и в нем своего наследника AbstractAnnotationConfigDispatcherServletInitializer

Создать конфигурационный класс спринга с аннотацией Configuration и ComponentScan, а также EnableSpringMVC, т.к. теперь у нас spring-mvc приложение
Этот класс должен наследоваться от WebMvcConfigurer
Внедряем applicationContext в конструкторе, а остальное вставляем из файла в видосе, там конфигурация таймлифа

В конфигурации tomcat реализуем второй метод с подстановкой спринг конфига и третий метод с подстановкой префиксного эндпоинта нашего сервлета
Также добавим зависимость javax servlet-api для AbstractAnnotationConfigDispatcherServletInitializer


lesson14

Создать два контроллера в отдельном пакете

Первый с эндпоинтами /hello /goodbye и префиксом /first с помощью RequestMapping()
На каждом из эндпоинтов ссылка на другой и ссылка на выход

Второй с эндпоинтом /exit
Здесь текст что ссылок больше нет

Шаблоны для каждого контроллера должны лежать в отдельной папке внутри views
Считается хорошим тоном разделять шаблоны разных контроллеров


lesson15

Нужно на /first/hello попробовать использовать параметры get-запроса

Для этого можно воспользоваться самим запросом и достать из него параметры через request.getParameter("name")
Если такого параметра нет, то вернется null
При этом (HttpServletRequest) request сам внедрится в метод, если мы пропишем его в аргументах

Либо аннотацией RequestParam("name"), которая пишется перед аргументами метода в контроллере
Если не указан параметр required в аннотации, то по умолчанию при отсутствии нужного параметра запроса будет возвращена ошибка 404

Еще нужно создать ссылку в шаблоне, которая позволила бы переходить на /first/hello с указанными url-параметрами


lesson16

Модель автоматически внедряется спрингом в параметр метода, если она там указана, как и HttpServletRequest

Нужно использовать шаблонизатор для отображения данных из модели
В модель в аттрибут message положим строку Hello {name} {surname}, которую выводили в консоль в прошлом уроке
Отобразим эту строку перед ссылками в параграфе, внутри тега используя th:text="${message}", которое подставляет текст
внутрь тега

Создать новый эндпоинт /first/calculator с методом get, куда в параметрах запроса будут приходить число a, число b,
строка action (add, sub, mul, div)
Нужно будет на странице отобразить результат выполнения операции action над a и b


lesson17

Начнем с пустого проекта и создадим модель Person с полями name и id
Создадим PersonDAO, который внутри пока что будет содержать массив с захардкоженными людьми и два метода: для извлечения
всех людей и для извлечения конкретного человека по id

Создадим PersonController, который пока что будет содержать два get-эндпоинта /people и /people/{id}
На первом возвращаем список из всех людей, а на втором возвращаем страницу с информацией по конкретному человеку

@PathVariable используется для вычленения переменных из пути эндпоинта
Пример
По пути /people/{id} можно расположить гет-эндпоинт, в параметрах которого можно прописать @PathVariable int id

С помощью th:href внутри тега можно динамически создавать url
Путь указывается так @{путь_с_переменными(переменная1=${}, переменная2=${})} (наверное не уверен)


lesson18

Нужно сделать страницу создания пользователя с формой, которая будет отображаться при get-запросе на адрес /people/new
Отправлять она должна post-запрос на /people

Для передачи метода в форме в thymeleaf используется th:method="...", для передачи экшна используется th:action="@{/...}",
Для передачи объекта, поля которого будут заполняться в форме, нужно использовать th:object="название_аттрибута_модели"

В инпутах на форме используется th:field="*{}" для указания заполняемого поля

Для передачи какого-то значения из модели в качестве параметра метода используется @ModelAttribiute("имя_аттрибута")
Если написать @ModelAttribute("название_аттрибута") перед методом, то в каждом методе контроллера мы сможем обращаться
к этому аттрибуту в модели (при этом его тип будет возвращаемым типом метода, над которым написана аннотация, а само
значение будет возвращаемым значением этого метода)

Добавить добавление пользователя в наш список в DAO

Если возвращать в методе не название шаблона, а "redirect:путь", то будет выполнен переход по указанному пути


lesson19

Добавим update и delete эндпоинты в наше приложение по адресам (GET people/{id}/edit, PATCH /people/{id}) и DELETE people/{id}
соответственно

В html5 есть только два метода отправки формы: get, post; но мы хотим использовать и другие: patch, delete, put
Для этого нужно передать их в форме через th:method=[patch, delete, put]
После этого внутри формы автоматически создастся
<input type="hidden" name="_method" value="[название переданного метода]">
Для обработки этого скрытого поля нужно использовать фильтр, который для всех запросов со скрытым полем _method будет
менять метод запроса с post/get на указанный


lesson20

В контроллере можно прописать аннотацию Valid на ModelAttribute, чтобы объект модели, соответствующий этому полю,
провалидировался после передачи контроллеру в качестве аргумента
Сразу же после этого аргумента нужно прописать аргумент типа BindingResult, чтобы получить в нем информацию о наличии
ошибок валидации

Формы для валидации поменяются следующим образом: мы добавим сообщение в любом теге для каждого поля, которое будет
отображаться только при наличии ошибок валидации в этом поле
Условное отображение делается при помощи th:if="#fields.hasErrors('имя поля')"
А передача ошибок для отображения делается при помощи th:errors="*{имя поля}"
Также включим отображение ошибок красным цветом с помощью аттрибута style="color: red"


lesson21

DDL (data definition language):
    create database db_name;
    drop database db_name;
    create table table_name(
        column1 type1,
        ...,
        columnN typeN
    );
    drop table table_name;

DML (data manipulation language):
    select * from table_name;
    insert into table_name(column1, column2) values (value1, value2);
    insert into table_name values (value1, value2);
    update table_name set column1=value1, column2=value2 where id=value_id;
    delete from table_name where id=value_id;

В этом уроке будем менять arraylist на базу данных

Сначала создадим базу данных в pgAdmin и подключимся к ней в идее
Затем создадим через консоль таблицу Person для людей с колонками id, name, age, email и типами int или varchar
Вставим в консоли несколько людей в эту таблицу

Нужно вставить зависимости для spring-jdbc и JDBC Driver для бд, а конкретно для PostgreSQL, искать в репозитории

Для подключения к бд нужно указать url бд, username пользователя бд, password этого пользователя
В PersonDAO нужно открыть Connection и в статическом инициализаторе его инициализировать
Сначала надо удостовериться, что драйвер находится в оперативной памяти, для этого нужно использовать рефлексию и Class.forName("путь_драйвера")
Затем можно инициализировать connection, используя url, username и password; с помощью DriverManager.getConnection(url, username, password)
Ошибки SQL и ненайденного класса драйвера нужно обработать

Statement - объект, который будет содержать запрос, который потом надо будет выполнить, создается он из connection'а
SQL-запрос пишется в строке, после чего исполняется с помощью statement.executeQuery(запрос) для получения данных и
statement.executeUpdate(запрос) для изменения таблицы
Результат запроса записывается в ResultSet, который представляет собой сколько-то строк таблицы
Чтобы получить очередную строку используется метод resultSet.next(), который возвращает boolean в зависимости от того,
получилось ли перейти на следующую строку или нет
Получать значения из строки после перемещения можно с помощью resultSet.get[Int, String, что-то еще(?)]("название_колонки")

Реализуем методы findAll и add


lesson22

Для выполнения запросов нужно использовать PreparedStatement вместо Statement, чтобы избежать SQL-инъекции(когда с формы
приходит текст, который способен выполниться как отдельное sql-выражение и сломать сервер)
Создается такой стейтмент тоже через connection, а конкретно через connection.prepareStatement
Там надо написать обычный запрос, но вместо конкретных значений, которые хочется взять из пришедшего в форме объекта,
нужно поставить вопросительные знаки
После этого можно прописать значения в этот statement с помощью preparedStatement.set[Int, String, что-то еще (?)](
позиция в запросе с 1, значение)

Еще одно важное отличие PreparedStatement от Statement заключается в том, что Statement при выполнении
statement.execute[Query, Update]("запрос") компилирует запрос каждый раз, а PreparedStatement компилирует запрос один раз,
но каждый раз изменяет значения в нем на то, что мы передаем через set[String, Int]()
Таким образом при множественном выполнении запросов на одном и том же statement'е PreparedStatement будет значительно быстрее

На практике реализуем все методы с помощью PreparedStatement в DAO и перепишем add() во избежание sql-инъекций


lesson23

Подключить spring-jdbc зависимость к проекту
Создать бин DataSource класса DriverManagerDataSource, который нужен для осуществления подключения к базе данных, в нем
заполнить url, username и password, а также имя драйвера, используемого jdbc
Потом нужно создать бин JdbcTemplate на основе бина DataSource

Последний бин внедрить в DAO, после чего можно стирать код создания подключения в бд, т.к. оно настроится само
Обращаться к jdbcTemplate можно с помощью query("prepared запрос", rowMapper, параметры sql-запроса...) или
update("prepared запрос", параметры sql-запроса...)
RowMapper нужен для преобразования полученных с помощью запроса данных в java-сущность, данные которой хранятся в таблице
Можно использовать BeanPropertyRowMapper<>(*класс в который нужно преобразовать*.class), он возьмет названия полей таблицы
и преобразует их из snake_case в camelCase, после чего использует соответствующие сеттеры для присвоения значений полям
java-объекта
Также можно определить и собственный rowMapper, который должен реализовывать интерфейс RowMapper<T>, где T - класс, в
объект которого мы хотим преобразовать данные из строки таблицы
В этом интерфейсе только один метод mapRow(ResultSet rs, int rowNumber), который должен обработать очередную строку
таблицы и построить на ее основе объект, после чего вернуть его


lesson24

Нужно убрать url, username и password в файл .properties, а потом подключить его с помощью
@PropertySource("classpath:путь до файла с значениями"), а затем вытащить из него значения с помощью Environment
А конкретно с помощью метода env.getProperty("название ключа")
В самом этом файле указываются пары ключ=значение и создавать его нужно в папке resources, которая должна находиться на
одном уровне с java
Его не нужно заливать на гит и вообще распространять, но для понятности нужно добавить файл .properties.origin, в
котором будут указаны только ключи, используемые в .properties
Так человеку, которых захочет локально запустить написанный нами код, будет понятно, что нужно указать в .properties
файле для работы приложения

Environment можно внедрить с помощью Spring, просто указав в конструкторе, не создавая вручную дополнительных бинов
Нужно не забывать, что существуют и системные переменные окружения, которые могут перезаписать значения из файла .properties
Во избежание этого лучше всем свойствам давать какой-то осмысленный префикс, чтобы не было коллизий имен


lesson25

Если нужно совершить множество одинаковых update-запросов с разными данными, лучше всего делать это с помощью batch-операций,
так как это будет значительно быстрее за счет распараллеливания запросов, а также отсутствия лишней инициализации
и деструкции после каждого из запросов, а они занимают большую часть времени операции

Создать новый контроллер для тестирования batch (от англ. партия) операций
В нем будет три эндпоинта: главная страница с двумя ссылками на оставшиеся эндпоинты
Первый будет производить 1000 операций вставки в обычном режиме, одну за другой
Второй будет производить 1000 операций вставки в batch-режиме
Оба должны засекать время и выводить на консоль (лучше на веб-страничку (так и сделал в итоге))
После завершения операций нужно перенаправлять на главную страницу со всеми пользователями
Нужно создать шаблоны для этого контроллера в соответствующей папке в views

В DAO появится три метода: для генерации списка из 1000 людей, для обычной вставки их всех, для вставки с помощью
batch-запроса

Для совершения batch-запроса нужно использовать jdbcTemplate.batchUpdate("запрос", batchPreparedStatementSetter)
BatchPreparedStatementSetter это интерфейс с двумя методами, первый из которых получает на вход preparedStatement,
указанный первым аргументом batchUpdate, и позицию в batch-е вторым аргументом
В этом методе нужно statement'у присвоить значения из i-ого объекта batch-а
Второй метод должен возвращать размер порции данных (оно же количество update-запросов)

Чтобы передать в модель какие-то данные при редиректе, нужно использовать RedirectAttributes::addFlashAttribute(ключ, значение)
Чтобы передать в параметры запроса при редиректе какие-то данные, можно испольщовать RedirectAttributes::addAttribute(ключ, значение)

Чтобы засекать время в Java используется System::currentTimeMillis, возвращающий long


lesson26

Обычно колонка id в таблице генерируется не на стороне сервера, а на стороне бд
Для этого используется в разных бд разный синтаксис

В MySQL, например, пишется AUTOINCREMENT, а в PostgreSQL - SERIAL или GENERATED BY DEFAULT AS IDENTITY

Для начала нужно понимать, что такое SEQUENCE
Это какая-то сущность, которую можно создать в консоли бд с помощью `create sequence название_последовательности`
Удалить ее можно с помощью drop sequence название_последовательности
Это что-то вроде итератора, который генерирует последовательные значения
С помощью select nextval(название_последовательности) можно получить очередное из них

Так вот указание SERIAL или INT GENERATED BY DEFAULT AS IDENTITY рядом с колонкой создает колонку и генерирует значения для
нее с помощью этой самой последовательности и функции nextval()
При имя последовательности будет такое: таблица_колонка_seq

На практике нужно дропнуть существующую таблицу и создать новую, где id будет генерироваться автоматически
После этого поменять добавление нового человека в DAO