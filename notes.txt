lesson4

Через сеттеры внедряется зависимость с помощью тега property с указанием name=имя поля и value=значение поля
values будем брать из файла *.properties, предварительно импортировав его в applicationContext с помощью тега <context:property-placeholder location="classpath:...">

При создании бина спринг сам ищет нужный конструктор в зависимости от внутренних <constructor-arg>

В property name=.. поиск ведется по сеттеру set..., где ... в camelCase'е

Надо создать в плеере две зависимости name и volume, внедрить все три зависимости с помощью property

Создать musicPlayer.properties и указать там name=...
volume=...

Нужно изменить плеер так, чтобы он мог проигрывать сразу много музыкальных жанров, то есть список
Потом внедрить все музыкальные жанры в плеер с помощью внедрения списка бинов

Можно передать лист бинов сразу через
<property/constructor-arg>
    <list>
        <ref="bean1">
        <ref="bean2">
        ...
    </list>
</...>

А можно как я сделал, тогда создается отдельный бин под лист

Выключил Inline completion


lesson5

Ставим scope=singleton для musicPlayer и убеждаемся, что они равны в TestSpring
То есть сравним ссылки и посмотрим, что будет при изменении громкости в одном из объектов
Затем ставим scope=prototype и смотрим, что ссылки теперь разные и что громкость меняется не в обеих переменных


lesson6

Добавим init-method и destroy-method в каком-то жанре музыки
В контексте с бинами для этого бина пропишем названия этих методов в init-method и destroy-method
Проверим, что init вызывается при создании бина, а точнее при создании контекста
Проверим, что дестрой вызывается при закрытии контекста, то есть при уничтожении бина

Модификатор доступа у этих методов может быть любой
Возвращаться может что угодно, но спринг все равно не будет это использовать
Входных аргументов у них быть не должно

У scope=prototype бинов не вызывается destroy-method
Спринг отдает бины клиенту и больше о них не заботится

Задание: посмотреть, вызывается ли дестрой метод у прототип бинов и посмотреть, сколько раз вызовется инит метод при создании нескольких прототип бинов

Первый инит вызывается при создании контекста у прототайпа, а дальше по мере вызова getBean()

factory-method:
    есть абстрактный класс Creator, который содержит всю бизнес логику обработки объекта, кроме реализации метода для создания экземпляра объекта
    при этом метод создания объекта абстрактный и возвращает интерфейс объектов, которые будут в итоге обработаны
    для каждого конкретного типа объекта мы создаем отдельные фабрики, в которых переопределяем метод создания объекта со всеми особенностями этого типа

Задание: создать фабричный метод в каком-то жанре и указать соответствующему бину называние этого метода через factory-method

Несмотря на то, что у нас будет фабричный метод, он все еще вызовется единственный раз при вызове getBean, если у нас scope=Singleton


lesson7

Теперь будем создавать бины через аннотации, а конкретнее пока что через @Component
Туда можно передать id=..., а иначе будет создан бин с названием класса с маленькой буквы

Сначала уберем создание всех бинов из xml конфигурации, а затем через тэг context:component-scan
Включим сканирование классов на бины передав base-package=путь до пути со всеми java-классами

Затем создадим бины для всех жанров музыки через Component и проверим в тест спринге


lesson8

Внедрять зависимости можно через @Autowired, который среди всех бинов ищет те, которые подходят по указанному для поля интерфейсу/классу

Ошибка будет, если таких бинов не нашлось или если их больше одного

При использовании внедрения зависимости через сеттер для Autowired неважно, какое будет название метода-сеттера

Для внедрения всех зависимостей в конструкторе можно поставить над ним Autowired

Прак
Создадим класс компьютер с id и musicPlayer'ом
В конструкторе установим id = 1, а musicPlayer внедрим через Autowired над конструктором
Переопределим ему toString(), чтобы возвращался id и какая музыка в плеере
В плеере сохраним все жанры музыки и внедрим их через конструктор

В итоге Autowired можно использовать с сеттером, конструктором или самим полем
В проекте лучше везде использовать одинаковый метод внедрения для лучшей читаемости кода


lesson9

Для решения проблемы с неоднозначностью подбора бинов, то есть когда их больше 1 на поле, можно использовать аннотацию @Qualifier
В ней указывается строчное имя бина, который нужно внедрить

Для внедрения зависимостей в конструкторе нужно для каждого аргумента в конструкторе указать Qualifier перед объявлением аргумента

Прак
Пусть внутри плеера будет две музыки, каждая с интерфейсом Music
Внедрим зависимости через конструктор, указав для каждой Qualifier, тк иначе будет неоднозначность и вылезет ошибка

Самозад:
1 Создать массив или список из 3 песен для каждого жанра
2 В плеере должны внедряться бины обоих жанров
3 Создать enum с жанрами музыки
4 Принимать в play() созданный enum
5 В зависимости от переданного жанра производить рандомную песню из списка песен этого жанра


lesson10

@Value("$название_ключа") - так можно внедрять константные зависимости из файла .properties с помощью аннотаций
При этом все так же надо будет создать этот файл и указать в нем пары ключ=значение и импортировать его в конфигурации
с помощью context:property-placeholder location="classpath:путь_до_файла"

Для создания бина с определенной областью видимости можно использовать после аннотации Component аннотацию
Scope("название_области")

@PostConstruct пишется над init-method'ом, а @PreDestroy - над destroy-method'ом
Для использования PreDestroy и PostContract

Эти аннотации являются аналогами уже изученного и ограничения на них такие же

Для работы этих аннотаций на Spring 5.3.* нужно подключить зависимость javax annotation-api
Для работы этих аннотаций 6.* нужно подключить зависимость jakarta annotation-api, которая с jdk 9 поглотила javax annotations-api

Задание
1 Подключаем файл .properties для плеера и внедряем значения имени и громкости с помощью них
Затем проверяем, внедрились ли они
2 Укажем scope singleton для классической музыки и проверим, равны ли два полученных из контекста бина этой музыки
Затем поменяем на prototype и увидим, что бины ссылаются на разные объекты
3 Проверим инит метод и дестрой метод для классической музыки, создав их


lesson11

@Configuration
Над классом, который будет использоваться в качестве конфигурации контекста спринг-приложения

@PropertySource("путь до .properties файла")
Тоже над классом-конфигурацией

@ComponentScan("путь до каталога со всеми java-классами")
Тоже над классом-конфигурацией

@Bean - для создания бина, над методом создания
Там можно прописать, как будет создаваться бин: с помощью фабрики или конструктора

Задание
Перенести всю конфигурацию в конфигурационный класс

Самозад
Сделать чтобы в плеере принимался лист из жанров музыки и еще один жанр
Внедрить с помощью бина-листа все три жанра в бин плеера и сделать в методе
play рандомный выбор жанра для воспроизведения


lesson12

Создаем собственное spring-mvc приложение, которое будет исполняться в tomcat
Для контроллера используется аннотация Controller, которая является надмножеством Component

web.xml считывается apache tomcat для конфигурации, а applicationContextMVC - конфигурация спринга

lesson13

Создать пакет config и в нем своего наследника AbstractAnnotationConfigDispatcherServletInitializer

Создать конфигурационный класс спринга с аннотацией Configuration и ComponentScan, а также EnableSpringMVC, т.к. теперь у нас spring-mvc приложение
Этот класс должен наследоваться от WebMvcConfigurer
Внедряем applicationContext в конструкторе, а остальное вставляем из файла в видосе, там конфигурация таймлифа

В конфигурации tomcat реализуем второй метод с подстановкой спринг конфига и третий метод с подстановкой префиксного эндпоинта нашего сервлета
Также добавим зависимость javax servlet-api для AbstractAnnotationConfigDispatcherServletInitializer


lesson14

Создать два контроллера в отдельном пакете

Первый с эндпоинтами /hello /goodbye и префиксом /first с помощью RequestMapping()
На каждом из эндпоинтов ссылка на другой и ссылка на выход

Второй с эндпоинтом /exit
Здесь текст что ссылок больше нет

Шаблоны для каждого контроллера должны лежать в отдельной папке внутри views
Считается хорошим тоном разделять шаблоны разных контроллеров


lesson15

Нужно на /first/hello попробовать использовать параметры get-запроса

Для этого можно воспользоваться самим запросом и достать из него параметры через request.getParameter("name")
Если такого параметра нет, то вернется null
При этом (HttpServletRequest) request сам внедрится в метод, если мы пропишем его в аргументах

Либо аннотацией RequestParam("name"), которая пишется перед аргументами метода в контроллере
Если не указан параметр required в аннотации, то по умолчанию при отсутствии нужного параметра запроса будет возвращена ошибка 404

Еще нужно создать ссылку в шаблоне, которая позволила бы переходить на /first/hello с указанными url-параметрами


lesson16

Модель автоматически внедряется спрингом в параметр метода, если она там указана, как и HttpServletRequest

Нужно использовать шаблонизатор для отображения данных из модели
В модель в аттрибут message положим строку Hello {name} {surname}, которую выводили в консоль в прошлом уроке
Отобразим эту строку перед ссылками в параграфе, внутри тега используя th:text="${message}", которое подставляет текст
внутрь тега

Создать новый эндпоинт /first/calculator с методом get, куда в параметрах запроса будут приходить число a, число b,
строка action (add, sub, mul, div)
Нужно будет на странице отобразить результат выполнения операции action над a и b
