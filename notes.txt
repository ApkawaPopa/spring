lesson4

Через сеттеры внедряется зависимость с помощью тега property с указанием name=имя поля и value=значение поля
values будем брать из файла *.properties, предварительно импортировав его в applicationContext с помощью тега <context:property-placeholder location="classpath:...">

При создании бина спринг сам ищет нужный конструктор в зависимости от внутренних <constructor-arg>

В property name=.. поиск ведется по сеттеру set..., где ... в camelCase'е

Надо создать в плеере две зависимости name и volume, внедрить все три зависимости с помощью property

Создать musicPlayer.properties и указать там name=...
volume=...

Нужно изменить плеер так, чтобы он мог проигрывать сразу много музыкальных жанров, то есть список
Потом внедрить все музыкальные жанры в плеер с помощью внедрения списка бинов

Можно передать лист бинов сразу через
<property/constructor-arg>
    <list>
        <ref="bean1">
        <ref="bean2">
        ...
    </list>
</...>

А можно как я сделал, тогда создается отдельный бин под лист

Выключил Inline completion


lesson5

Ставим scope=singleton для musicPlayer и убеждаемся, что они равны в TestSpring
То есть сравним ссылки и посмотрим, что будет при изменении громкости в одном из объектов
Затем ставим scope=prototype и смотрим, что ссылки теперь разные и что громкость меняется не в обеих переменных


lesson6

Добавим init-method и destroy-method в каком-то жанре музыки
В контексте с бинами для этого бина пропишем названия этих методов в init-method и destroy-method
Проверим, что init вызывается при создании бина, а точнее при создании контекста
Проверим, что дестрой вызывается при закрытии контекста, то есть при уничтожении бина

Модификатор доступа у этих методов может быть любой
Возвращаться может что угодно, но спринг все равно не будет это использовать
Входных аргументов у них быть не должно

У scope=prototype бинов не вызывается destroy-method
Спринг отдает бины клиенту и больше о них не заботится

Задание: посмотреть, вызывается ли дестрой метод у прототип бинов и посмотреть, сколько раз вызовется инит метод при создании нескольких прототип бинов

Первый инит вызывается при создании контекста у прототайпа, а дальше по мере вызова getBean()

factory-method:
    есть абстрактный класс Creator, который содержит всю бизнес логику обработки объекта, кроме реализации метода для создания экземпляра объекта
    при этом метод создания объекта абстрактный и возвращает интерфейс объектов, которые будут в итоге обработаны
    для каждого конкретного типа объекта мы создаем отдельные фабрики, в которых переопределяем метод создания объекта со всеми особенностями этого типа

Задание: создать фабричный метод в каком-то жанре и указать соответствующему бину называние этого метода через factory-method

Несмотря на то, что у нас будет фабричный метод, он все еще вызовется единственный раз при вызове getBean, если у нас scope=Singleton


lesson7

Теперь будем создавать бины через аннотации, а конкретнее пока что через @Component
Туда можно передать id=..., а иначе будет создан бин с названием класса с маленькой буквы

Сначала уберем создание всех бинов из xml конфигурации, а затем через тэг context:component-scan
Включим сканирование классов на бины передав base-package=путь до пути со всеми java-классами

Затем создадим бины для всех жанров музыки через Component и проверим в тест спринге


lesson8

Внедрять зависимости можно через @Autowired, который среди всех бинов ищет те, которые подходят по указанному для поля интерфейсу/классу

Ошибка будет, если таких бинов не нашлось или если их больше одного

При использовании внедрения зависимости через сеттер для Autowired неважно, какое будет название метода-сеттера

Для внедрения всех зависимостей в конструкторе можно поставить над ним Autowired

Прак
Создадим класс компьютер с id и musicPlayer'ом
В конструкторе установим id = 1, а musicPlayer внедрим через Autowired над конструктором
Переопределим ему toString(), чтобы возвращался id и какая музыка в плеере
В плеере сохраним все жанры музыки и внедрим их через конструктор

В итоге Autowired можно использовать с сеттером, конструктором или самим полем
В проекте лучше везде использовать одинаковый метод внедрения для лучшей читаемости кода


lesson9

Для решения проблемы с неоднозначностью подбора бинов, то есть когда их больше 1 на поле, можно использовать аннотацию @Qualifier
В ней указывается строчное имя бина, который нужно внедрить

Для внедрения зависимостей в конструкторе нужно для каждого аргумента в конструкторе указать Qualifier перед объявлением аргумента

Прак
Пусть внутри плеера будет две музыки, каждая с интерфейсом Music
Внедрим зависимости через конструктор, указав для каждой Qualifier, тк иначе будет неоднозначность и вылезет ошибка

Самозад:
1 Создать массив или список из 3 песен для каждого жанра
2 В плеере должны внедряться бины обоих жанров
3 Создать enum с жанрами музыки
4 Принимать в play() созданный enum
5 В зависимости от переданного жанра производить рандомную песню из списка песен этого жанра


lesson10

@Value("$название_ключа") - так можно внедрять константные зависимости из файла .properties с помощью аннотаций
При этом все так же надо будет создать этот файл и указать в нем пары ключ=значение и импортировать его в конфигурации
с помощью context:property-placeholder location="classpath:путь_до_файла"

Для создания бина с определенной областью видимости можно использовать после аннотации Component аннотацию
Scope("название_области")

@PostConstruct пишется над init-method'ом, а @PreDestroy - над destroy-method'ом
Для использования PreDestroy и PostContract

Эти аннотации являются аналогами уже изученного и ограничения на них такие же

Для работы этих аннотаций на Spring 5.3.* нужно подключить зависимость javax annotation-api
Для работы этих аннотаций 6.* нужно подключить зависимость jakarta annotation-api, которая с jdk 9 поглотила javax annotations-api

Задание
1 Подключаем файл .properties для плеера и внедряем значения имени и громкости с помощью них
Затем проверяем, внедрились ли они
2 Укажем scope singleton для классической музыки и проверим, равны ли два полученных из контекста бина этой музыки
Затем поменяем на prototype и увидим, что бины ссылаются на разные объекты
3 Проверим инит метод и дестрой метод для классической музыки, создав их


lesson11

@Configuration
Над классом, который будет использоваться в качестве конфигурации контекста спринг-приложения

@PropertySource("путь до .properties файла")
Тоже над классом-конфигурацией

@ComponentScan("путь до каталога со всеми java-классами")
Тоже над классом-конфигурацией

@Bean - для создания бина, над методом создания
Там можно прописать, как будет создаваться бин: с помощью фабрики или конструктора

Задание
Перенести всю конфигурацию в конфигурационный класс

Самозад
Сделать чтобы в плеере принимался лист из жанров музыки и еще один жанр
Внедрить с помощью бина-листа все три жанра в бин плеера и сделать в методе
play рандомный выбор жанра для воспроизведения


lesson12

Создаем собственное spring-mvc приложение, которое будет исполняться в tomcat
Для контроллера используется аннотация Controller, которая является надмножеством Component

web.xml считывается apache tomcat для конфигурации, а applicationContextMVC - конфигурация спринга

lesson13

Создать пакет config и в нем своего наследника AbstractAnnotationConfigDispatcherServletInitializer

Создать конфигурационный класс спринга с аннотацией Configuration и ComponentScan, а также EnableSpringMVC, т.к. теперь у нас spring-mvc приложение
Этот класс должен наследоваться от WebMvcConfigurer
Внедряем applicationContext в конструкторе, а остальное вставляем из файла в видосе, там конфигурация таймлифа

В конфигурации tomcat реализуем второй метод с подстановкой спринг конфига и третий метод с подстановкой префиксного эндпоинта нашего сервлета
Также добавим зависимость javax servlet-api для AbstractAnnotationConfigDispatcherServletInitializer


lesson14

Создать два контроллера в отдельном пакете

Первый с эндпоинтами /hello /goodbye и префиксом /first с помощью RequestMapping()
На каждом из эндпоинтов ссылка на другой и ссылка на выход

Второй с эндпоинтом /exit
Здесь текст что ссылок больше нет

Шаблоны для каждого контроллера должны лежать в отдельной папке внутри views
Считается хорошим тоном разделять шаблоны разных контроллеров


lesson15

Нужно на /first/hello попробовать использовать параметры get-запроса

Для этого можно воспользоваться самим запросом и достать из него параметры через request.getParameter("name")
Если такого параметра нет, то вернется null
При этом (HttpServletRequest) request сам внедрится в метод, если мы пропишем его в аргументах

Либо аннотацией RequestParam("name"), которая пишется перед аргументами метода в контроллере
Если не указан параметр required в аннотации, то по умолчанию при отсутствии нужного параметра запроса будет возвращена ошибка 404

Еще нужно создать ссылку в шаблоне, которая позволила бы переходить на /first/hello с указанными url-параметрами


lesson16

Модель автоматически внедряется спрингом в параметр метода, если она там указана, как и HttpServletRequest

Нужно использовать шаблонизатор для отображения данных из модели
В модель в аттрибут message положим строку Hello {name} {surname}, которую выводили в консоль в прошлом уроке
Отобразим эту строку перед ссылками в параграфе, внутри тега используя th:text="${message}", которое подставляет текст
внутрь тега

Создать новый эндпоинт /first/calculator с методом get, куда в параметрах запроса будут приходить число a, число b,
строка action (add, sub, mul, div)
Нужно будет на странице отобразить результат выполнения операции action над a и b


lesson17

Начнем с пустого проекта и создадим модель Person с полями name и id
Создадим PersonDAO, который внутри пока что будет содержать массив с захардкоженными людьми и два метода: для извлечения
всех людей и для извлечения конкретного человека по id

Создадим PersonController, который пока что будет содержать два get-эндпоинта /people и /people/{id}
На первом возвращаем список из всех людей, а на втором возвращаем страницу с информацией по конкретному человеку

@PathVariable используется для вычленения переменных из пути эндпоинта
Пример
По пути /people/{id} можно расположить гет-эндпоинт, в параметрах которого можно прописать @PathVariable int id

С помощью th:href внутри тега можно динамически создавать url
Путь указывается так @{путь_с_переменными(переменная1=${}, переменная2=${})} (наверное не уверен)


lesson18

Нужно сделать страницу создания пользователя с формой, которая будет отображаться при get-запросе на адрес /people/new
Отправлять она должна post-запрос на /people

Для передачи метода в форме в thymeleaf используется th:method="...", для передачи экшна используется th:action="@{/...}",
Для передачи объекта, поля которого будут заполняться в форме, нужно использовать th:object="название_аттрибута_модели"

В инпутах на форме используется th:field="*{}" для указания заполняемого поля

Для передачи какого-то значения из модели в качестве параметра метода используется @ModelAttribiute("имя_аттрибута")
Если написать @ModelAttribute("название_аттрибута") перед методом, то в каждом методе контроллера мы сможем обращаться
к этому аттрибуту в модели (при этом его тип будет возвращаемым типом метода, над которым написана аннотация, а само
значение будет возвращаемым значением этого метода)

Добавить добавление пользователя в наш список в DAO

Если возвращать в методе не название шаблона, а "redirect:путь", то будет выполнен переход по указанному в пути url


lesson19

Добавим update и delete эндпоинты в наше приложение по адресам (GET people/{id}/edit, PATCH /people/{id}) и DELETE people/{id}
соответственно

В html5 есть только два метода отправки формы: get, post; но мы хотим использовать и другие: patch, delete, put
Для этого нужно передать их в форме через th:method=[patch, delete, put]
После этого внутри формы автоматически создастся
<input type="hidden" name="_method" value="[название переданного метода]">
Для обработки этого скрытого поля нужно использовать фильтр, который для всех запросов со скрытым полем _method будет
менять метод запроса с post/get на указанный


lesson20

В контроллере можно прописать аннотацию Valid на ModelAttribute, чтобы объект модели, соответствующий этому полю,
провалидировался после передачи контроллеру в качестве аргумента
Сразу же после этого аргумента нужно прописать аргумент типа BindingResult, чтобы получить в нем информацию о наличии
ошибок валидации

Формы для валидации поменяются следующим образом: мы добавим сообщение в любом теге для каждого поля, которое будет
отображаться только при наличии ошибок валидации в этом поле
Условное отображение делается при помощи th:if="#fields.hasErrors('имя поля')"
А передача ошибок для отображения делается при помощи th:errors="*{имя поля}"
Также включим отображение ошибок красным цветом с помощью аттрибута style="color: red"


lesson21

DDL (data definition language):
    create database db_name;
    drop database db_name;
    create table table_name(
        column1 type1,
        ...,
        columnN typeN
    );
    drop table table_name;

DML (data manipulation language):
    select * from table_name;
    insert into table_name(column1, column2) values (value1, value2);
    insert into table_name values (value1, value2);
    update table_name set column1=value1, column2=value2 where id=value_id;
    delete from table_name where id=value_id;

В этом уроке будем менять arraylist на базу данных

Сначала создадим базу данных в pgAdmin и подключимся к ней в идее
Затем создадим через консоль таблицу Person для людей с колонками id, name, age, email и типами int или varchar
Вставим в консоли несколько людей в эту таблицу

Нужно вставить зависимости для spring-jdbc и JDBC Driver для бд, а конкретно для PostgreSQL, искать в репозитории

Для подключения к бд нужно указать url бд, username пользователя бд, password этого пользователя
В PersonDAO нужно открыть Connection и в статическом инициализаторе его инициализировать
Сначала надо удостовериться, что драйвер находится в оперативной памяти, для этого нужно использовать рефлексию и Class.forName("путь_драйвера")
Затем можно инициализировать connection, используя url, username и password; с помощью DriverManager.getConnection(url, username, password)
Ошибки SQL и ненайденного класса драйвера нужно обработать

Statement - объект, который будет содержать запрос, который потом надо будет выполнить, создается он из connection'а
SQL-запрос пишется в строке, после чего исполняется с помощью statement.executeQuery(запрос) для получения данных и
statement.executeUpdate(запрос) для изменения таблицы
Результат запроса записывается в ResultSet, который представляет собой сколько-то строк таблицы
Чтобы получить очередную строку используется метод resultSet.next(), который возвращает boolean в зависимости от того,
получилось ли перейти на следующую строку или нет
Получать значения из строки после перемещения можно с помощью resultSet.get[Int, String, что-то еще(?)]("название_колонки")

Реализуем методы findAll и add


lesson22

Для выполнения запросов нужно использовать PreparedStatement вместо Statement, чтобы избежать SQL-инъекции(когда с формы
приходит текст, который способен выполниться как отдельное sql-выражение и сломать сервер)
Создается такой стейтмент тоже через connection, а конкретно через connection.prepareStatement
Там надо написать обычный запрос, но вместо конкретных значений, которые хочется взять из пришедшего в форме объекта,
нужно поставить вопросительные знаки
После этого можно прописать значения в этот statement с помощью preparedStatement.set[Int, String, что-то еще (?)](
позиция в запросе с 1, значение)

Еще одно важное отличие PreparedStatement от Statement заключается в том, что Statement при выполнении
statement.execute[Query, Update]("запрос") компилирует запрос каждый раз, а PreparedStatement компилирует запрос один раз,
но каждый раз изменяет значения в нем на то, что мы передаем через set[String, Int]()
Таким образом при множественном выполнении запросов на одном и том же statement'е PreparedStatement будет значительно быстрее

На практике реализуем все методы с помощью PreparedStatement в DAO и перепишем add() во избежание sql-инъекций


lesson23

Подключить spring-jdbc зависимость к проекту
Создать бин DataSource класса DriverManagerDataSource, который нужен для осуществления подключения к базе данных, в нем
заполнить url, username и password, а также имя драйвера, используемого jdbc
Потом нужно создать бин JdbcTemplate на основе бина DataSource

Последний бин внедрить в DAO, после чего можно стирать код создания подключения в бд, т.к. оно настроится само
Обращаться к jdbcTemplate можно с помощью query("prepared запрос", rowMapper, параметры sql-запроса...) или
update("prepared запрос", параметры sql-запроса...)
RowMapper нужен для преобразования полученных с помощью запроса данных в java-сущность, данные которой хранятся в таблице
Можно использовать BeanPropertyRowMapper<>(*класс в который нужно преобразовать*.class), он возьмет названия полей таблицы
и преобразует их из snake_case в camelCase, после чего использует соответствующие сеттеры для присвоения значений полям
java-объекта
Также можно определить и собственный rowMapper, который должен реализовывать интерфейс RowMapper<T>, где T - класс, в
объект которого мы хотим преобразовать данные из строки таблицы
В этом интерфейсе только один метод mapRow(ResultSet rs, int rowNumber), который должен обработать очередную строку
таблицы и построить на ее основе объект, после чего вернуть его


lesson24

Нужно убрать url, username и password в файл .properties, а потом подключить его с помощью
@PropertySource("classpath:путь до файла с значениями"), а затем вытащить из него значения с помощью Environment
А конкретно с помощью метода env.getProperty("название ключа")
В самом этом файле указываются пары ключ=значение и создавать его нужно в папке resources, которая должна находиться на
одном уровне с java
Его не нужно заливать на гит и вообще распространять, но для понятности нужно добавить файл .properties.origin, в
котором будут указаны только ключи, используемые в .properties
Так человеку, которых захочет локально запустить написанный нами код, будет понятно, что нужно указать в .properties
файле для работы приложения

Environment можно внедрить с помощью Spring, просто указав в конструкторе, не создавая вручную дополнительных бинов
Нужно не забывать, что существуют и системные переменные окружения, которые могут перезаписать значения из файла .properties
Во избежание этого лучше всем свойствам давать какой-то осмысленный префикс, чтобы не было коллизий имен


lesson25

Если нужно совершить множество одинаковых update-запросов с разными данными, лучше всего делать это с помощью batch-операций,
так как это будет значительно быстрее за счет распараллеливания запросов, а также отсутствия лишней инициализации
и деструкции после каждого из запросов, а они занимают большую часть времени операции

Создать новый контроллер для тестирования batch (от англ. партия) операций
В нем будет три эндпоинта: главная страница с двумя ссылками на оставшиеся эндпоинты
Первый будет производить 1000 операций вставки в обычном режиме, одну за другой
Второй будет производить 1000 операций вставки в batch-режиме
Оба должны засекать время и выводить на консоль (лучше на веб-страничку (так и сделал в итоге))
После завершения операций нужно перенаправлять на главную страницу со всеми пользователями
Нужно создать шаблоны для этого контроллера в соответствующей папке в views

В DAO появится три метода: для генерации списка из 1000 людей, для обычной вставки их всех, для вставки с помощью
batch-запроса

Для совершения batch-запроса нужно использовать jdbcTemplate.batchUpdate("запрос", batchPreparedStatementSetter)
BatchPreparedStatementSetter это интерфейс с двумя методами, первый из которых получает на вход preparedStatement,
указанный первым аргументом batchUpdate, и позицию в batch-е вторым аргументом
В этом методе нужно statement'у присвоить значения из i-ого объекта batch-а
Второй метод должен возвращать размер порции данных (оно же количество update-запросов)

Чтобы передать в модель какие-то данные при редиректе, нужно использовать RedirectAttributes::addFlashAttribute(ключ, значение)
Чтобы передать в параметры запроса при редиректе какие-то данные, можно испольщовать RedirectAttributes::addAttribute(ключ, значение)

Чтобы засекать время в Java используется System::currentTimeMillis, возвращающий long


lesson26

Обычно колонка id в таблице генерируется не на стороне сервера, а на стороне бд
Для этого используется в разных бд разный синтаксис

В MySQL, например, пишется AUTOINCREMENT, а в PostgreSQL - SERIAL или GENERATED BY DEFAULT AS IDENTITY

Для начала нужно понимать, что такое SEQUENCE
Это какая-то сущность, которую можно создать в консоли бд с помощью `create sequence название_последовательности`
Удалить ее можно с помощью drop sequence название_последовательности
Это что-то вроде итератора, который генерирует последовательные значения
С помощью select nextval(название_последовательности) можно получить очередное из них

Так вот указание SERIAL или INT GENERATED BY DEFAULT AS IDENTITY рядом с колонкой создает колонку и генерирует значения для
нее с помощью этой самой последовательности и функции nextval()
При этом имя последовательности будет такое: таблица_колонка_seq

На практике нужно дропнуть существующую таблицу и создать новую, где id будет генерироваться автоматически
После этого поменять добавление нового человека в DAO


lesson27

В бд можно ставить ограничения на колонки
Основные: unique, primary key, foreign key ((наверное)таблица колонка), check (условие), not null
Для нашей таблицы имеют места ограничения primary key для id, not null для name, check (age > 0) для age, not null
unique для email

Теперь при попытке обойти эти ограничения, например, при добавлении пользователя с таким же email,
будет выбрасываться sql-эксепшн, который приведет к коду 500 (пока что)


lesson28

Создаем таблицу режиссеров Director с колонками id с автогенерацией, age, name не более 100 символов
Потом создаем таблицу фильмов Movie с колонками id с автогенерацией, внешним ключом director_id с помощью ключевого
слова REFERENCES Таблица(колонка), name не более 200 символов, year_of_production с условием на > 1900

Создать таблицу паспортов и граждан один к одному у паспорта только номер и id гражданина у гражданина id, name, age

Создать таблицу актеров и соединительную таблицу актеров и фильмов для демонстрации многие ко многим
У актера есть id, name, age

Ну в общем есть отношения один к одному когда в дочерней таблице есть foreign key на id из родительской и оно же primary
key в дочерней

Есть один ко многим когда в дочерней таблице есть foreign key на id из родительской, но в дочерней свой primary key
foreign key контролирует, чтобы нельзя было вставить в дочернюю таблицу строку, где колонка, которая ссылается на
родительскую таблицу не имела бы значение одной из строк этой родительской таблицы
То есть надо чтобы в этой колонке было значение, которое совпадает с одним из значений primary key колонки в родительской
таблице

Есть еще многие ко многим, в таком случае создается соединительная таблица, в которой две колонки, каждая из которых
это foreign key на primary key колонку каждой из этих таблиц
То есть там описываются пары строк из двух, которые связаны между собой


lesson29

Есть такая штука как индекс
Он создается для ускорения поисковых запросов по таблице при использовании определенной колонки
Синтаксис создания индекса:
create index название_индекса on таблица(индексируемая_колонка) using [B-Tree, Hash, GiST, SP-GiST, GIN, BRIN]
В квадратных скобках разные типы индексов

При создании индекса создается дополнительная сущность, в которой хранятся значения индексируемой колонки и id строки с
этим значением
Используя B-Tree индекс, например, значения сортируются и поиск осуществляется за log(n) с помощью двоичного поиска,
но скорее всего не совсем ведь не зря это бинарное дерево, там наверное просто идет спуск по этому дереву, что, впрочем,
похоже на двоичный поиск

Но урок не об этом, а о удалении и его последствиях
При создании внешнего ключа можно указать поведение при удалении строки из таблицы с первичным ключом

Синтаксис:
create table Child(
    id int references Parent(id) on delete [cascade, set null, restrict]
)

cascade при удалении значения в родительской таблице удаляет все связанные строки из дочерней
set null помещает null во все связанные строки в колонку с внешним ключом
restrict это поведение по умолчанию и оно выбрасывает ошибку при попытке удалить строку из родительской таблицы


lesson 30

Сейчас при добавлении человека с электронной почтой, которая уже есть в бд, сервер выбрасывает 500ку, однако
хочется сделать так, чтобы эта ошибка обрабатывалась и выводилась пользователю в более дружелюбном виде

Для передачи ошибок в errors можно использовать rejectValue(название поля, код ошибки, описание ошибки)
При этом метод в сам метод validate в контроллере будут передаваться person и bindingResult

Замечание: лучше использовать optional.isPresent(), когда возможно

Для этих целей существует Validator
Это интерфейс, в котором есть два метода: supports для определения, какой класс будет валидироваться, и
validate для, собственно, валидации переданного через форму объекта и передачи сообщений об ошибках

Нужно создать собственный валидатор для людей, который бы проверял уникальность email
Он должен находиться в пакете util
Для проверки, есть ли человек с таким email в бд, нужно будет создать отдельный метод в PersonDAO


lesson 31

Добавим в таблицу Person колонку address. Она должна иметь формат "Страна, Город, Индекс", индекс состоит
из 6 цифр

Сначала удалим всех людей из таблицы Person с помощью truncate table Person
Затем добавим в эту таблицу колонку с помощью alter table Person add column address varchar not null

Для валидации поля модели с помощью регулярного выражения можно использовать аннотацию @Pattern(regexp = "...")

Нашелся баг: check в таблице для age > 0, а надо >= 0


lesson 32

В html есть выпадающие списки
Они создаются так:
<select id="selectId" name="selectName">
    <option value="value1">Text1</option>
    ...
    <option value="valueN">TextN</option>
</select>

Обычно помещаются внутри формы и отправляются вместе с остальными полями
В теле запроса находится внутри form.selectName

В thymeleaf выпадающие списки создаются так:
<select th:object="${object}" th:field="*{objectField}" id="selectId">
    <option
        th:each="object : ${objectList}"
        th:value="${object.getValue()}
        th:text="${object.getText()}"></option>
</select>

Нужно добавить страницу /admin с выпадающим списком всех людей, на которой будет выбираться администратор среди всех
существующих людей
При отправке выбора в консоль должен выводиться текст "New administrator: " + person.getFullName()

Нужно будет создать новый контроллер для /admin, в котором будет обработчик get / и put /set

Добавить в модель пустой объект можно с помощью @ModelAttribute

URL в thymeleaf указывается с помощью @{}


lesson 33

Классы в Java очень похожи на таблицы в базе данных. У них есть названия, как и у таблиц, и объекты, как строки в
таблицах. Поэтому есть такая вещи как Object Relational Mapping - объектное реляционное отображение. Оно устанавливает
связь между таблицами и классами (строками таблиц и объектами классов).

В Java есть реализация этого ORM - Hibernate

Чтобы настроить ORM с помощью hibernate, нужно использовать зависимость hibernate-core, создать класс, который мы хотим
связать с таблицой в БД, а также создать hibernate.properties (важно, чтобы имя файла было именно такое) в resources.

В hibernate.properties должна быть конфигурация источника данных и конфигурация самого hibernate

Data Source:
hibernate.driver_class - класс JDBC драйвера
hibernate.connection.url - url для создания соединения с БД
hibernate.connection.username - имя пользователя для создания соединения с БД
hibernate.connection.password - пароль для создания соединения с БД

Hibernate:
hibernate.dialect - диалект, который должен использоваться для создания запросов к БД
В случае postgres - org.hibernate.dialect.PostgreSQLDialect
hibernate.show_sql (true, false) - отображение сгенерированных запросов с консоли
hibernate.current_session_context_class=thread (что-то контекст)

Создать нужно новую БД, а в ней таблицу person (id, name, age)
Там создать одного человека для демонстрации

Чтобы связать эту таблицу с классом, нужно создать класс Person и написать над ним аннотацию @Entity
Также можно использовать аннотацию @Table(name = "") для указания названия таблицы, с которой будет связан класс
Все классы-сущности должны иметь пустой конструктор и хотя бы одно поле, помеченное как @Id - первичный ключ
Каждому полю из класса нужно сопоставить столбец из таблицы с помощью @Column(name = "название колонки")
Аннотация @Id помечает первичный ключ таблицы

Также хорошо бы генерировать все геттеры и сеттеры (не уверен, что нужно)

Теперь, для создания запросов к таблице из кода, нужно сначала создать в main() конфигурацию
Hibernate (org.hibernate.cfg.Configuration)
Потом добавить в нее сущность с помощью метода addAnnotatedClass(Smth.class)

Затем нужно создать SessionFactory через метод конфигурации buildSessionFactory()
Потом этой фабрикой взять сессию через getCurrentSession()
Далее открываем транзакцию через сессию через beginTransaction();
Далее выполняем все нужные запросы через сессию опять же
Например, для получения объекта с каким-то конкретным id нужно использовать session.get(YourEntity.class, targetId);
Закрыть транзакцию можно через session.getTransaction().commit();
SessionFactory - ресурс, поэтому его надо обязательно закрыть

При запуске приложения в консоли будут видны все sql-команды, которые использовал hibernate


lesson 34

Если значения для какой-то колонки генерируются в таблице автоматически, нужно указать это аннотацией @GeneratedValue
над соответствующим полем в сущности
Параметр этой аннотации strategy отвечает за поведение hibernate при генерации
значения для этого поля

При strategy = GenerationType.IDENTITY Hibernate полностью делегирует работу со значением в
этой колонке базе данных

При GenerationType.SEQUENCE - берет созданную в БД последовательность и достает из нее
следующее значение, после чего присваивает его этому полю (и строке в БД тоже, наверное)
Чтобы Hibernate нашел нужную последовательность, указывается
@SequenceGenerator(name = имя генератора, sequenceName = имя последовательности со значениями)

Также существует GenerationType.TABLE, когда для генерации значения нужна другая таблица

Задание1:
Создать конструктор для всех полей кроме id
Создать трех новых людей и добавить их в базу данных при помощи session.save()

Задание2:
Чтобы посмотреть, как работает GenerationType.SEQUENCE, сотрем существующую таблицу и создадим новую, в которой id не
генерируется автоматически
Отдельно создадим sequence person_id_seq
Укажем нужный тип генерации для id и заполним @SequenceGenerator
Там нужно будет заполнить еще allocationSize, оно отвечает за кратность итогового сгенерированного значения
То есть будет присваиваться значение (nextval sequence) * allocationSize
При этом заполненный allocationSize должен совпадать с allocationSize созданной в бд последовательности, а иначе вылетит
исключение